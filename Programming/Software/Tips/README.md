
# Software
What is Software?
-   Software = Programs
-   Programs = a set of computer instructions for carrying out computing tasks
-   Programmer = He or She that attempts to correctly structure those instructions to achieve a desired result
# What is Computer Science?

-   Not using a computer
    
-   Not just programming
    
-   A field at the intersection of Math, Engineering, etc
    
![sunlab](https://lh5.googleusercontent.com/nml-rAmvE76zbwJWrvpfc-Hwfb7uCRW4Y5MITuusFUMz_PtiJ0z5D9b4WGenpVR45b532Hkw1NmSETpZBkZ3--12wiWZlEPkQVEwZTiEFfIsww5LBuVaYv1Hi5UpjtX2t803M1MUzlzumB0=s2048)  

## The Algorithm

-   Fundamental inventions in formal thinking:
    

-   Formal Logic (Athens, ~4 C. AD)
    
-   Mathematical Proof (Greece, ~585 AD)
    
-   Secular Observation of Nature  
    (~600 AD)
    
-   Arabic Numerals, including Zero  
    (India, ~8 C. AD)
    
-   Algebra (al-Khwarizmi, ~810 AD)
    
-   Probability (late 1500's)
    
-   Scientific Method (early 1600s)
    
-   Now: The Algorithm
    
![al-Khwarizmi](https://lh5.googleusercontent.com/PU4SDpG5ZccGQSGEqFIgLoCLUfXzhMkA-ntrm_3axpBA2ij14Cheh0zOeG5wSPcaKNJjrygQNGbWwrAf38PLavexFEhNorzEonyc1HzxkDL_d16s6X2vpSQchx8QX8P9gMPTXylGXE2H3Qk=s2048)  

## Computer Scientists
![nerd](https://lh6.googleusercontent.com/D2QNYHUb6mBwVAFmeHVYMTydBGdqek1t72VoWWBp_qKfE9p7LQN6dnsBKuaDq496yo3d7u4wD3Xds1yMLwm06R7rxCf8uWs1XtFN9utELj8qaXZGD0delXJBYr5S2vUSYrsgSOupgCTVWRQ=s2048)  

-   Who are Computer Scientists?
    
-   Computer Scientists study lots of things
    
-   e.g., "What are Algorithms Theoretically Capable of?“
    
-   Can Machines Think?
    
-   Today we're going to look at the applied version: Programming
    
## Computer Programmers
 “Their rumpled clothes, their unwashed and unshaven faces, and their uncombed hair all testify that they are oblivious to their bodies and to the world in which they move. These are computer bums, compulsive programmers.”
## Computer Science as the New Literacy

-   The modes of thought that come from CS are influencing a huge number of fields
    
-   Modeling & Simulation
    

-   We can create all sorts of worlds inside the computer to work with
    
![simulation](https://lh3.googleusercontent.com/3-mPoui5v4Qg2x5xmqNIZAng1zt7bsLCioDT7QLKzYpz7cv2wvfXGFzInwNYxJL_ZPYUN5eP54GoUj_tZL7BAA1hFAEKclXfC5UV8eHVf62aaLYzTD1f0NjZnhwzkFWaiQvahSYsJkfzLZQ=s2048)  


Computer Programmers;  
a definition

  

 “Their rumpled clothes, their unwashed and unshaven faces, and their uncombed hair all testify that they are oblivious to their bodies and to the world in which they move. These are computer bums, compulsive programmers.”



Programmers having fun at work

![fist of the northstar](https://lh5.googleusercontent.com/ap5M1pyDRhS2iqCwspVU8mGHX4axG5_P18NVBQMkU1Q9R7qXpBW567YE6kZ_ncFZy9CEdbPKv5F0AnG45PyopiNiynAKCyJ_el_Zrzw7qbrixs9Z7-fmD01vWtDYifPXgsFxdtqXpdjLGdE=s2048)  

“The trouble with programmers is that you can never tell what they are doing until it’s too late.”



Programming Language

  

-   A programming language is a convenient way of expressing instructions for a computer to execute
    

  

-    Computer languages have evolved to the point where anyone can learn the basics of using one
    




Low and High Level Languages

  

-   Programming languages are divided up into low-level languages and high-level languages.
    

  

-   The closer the language is to machine language, the lower the level.
    

  

-   High level languages make it much easier to develop large complex programs.
    





Machine Language

  

-   Every computer CPU has its machine language, the set of instructions it knows how to execute. This is the lowest level. 
    

  

-   A typical instruction might say, get the contents of a memory location and put it in the accumulator (perhaps in preparation for adding it to another number).
    




A Machine Language Program

  

-   Put contents of memory location 10 in accumulator.
    

  

-   Add contents of memory location 11 to accumulator.
    

  

-   Put contents of accumulator back in location 10
    

  

-   It might look like
    

110011011111100111110000011110000010000011111

100010001000100100001000001111000001110000000

010000100010010000101010000111001110000011000                               

  
  

…..not very user friendly!  But believe it or not, computers were programmed by humans in machine language at one time.




Natural Languages

  

-   Computers don’t understand English
    
-   Need to deal with
    

-   Ambiguity
    
-   Redundancy
    
-   Literalness
    

  
  

-   So, we express what a computer should do in a formal language
    


 


Assembly Language

  

-   Assembly language is machine language made slightly easier.
    

  

-   LDACC 0A    ; (current_balance)
    
-   ADD 0B         ; (add new_check)
    
-   STACC 0A     ; (store new_balance)
    




High-Level Languages

  

In a high-level language the previous piece of code might look like this:

  

Input current_balance

current_balance = current_balance +new_check;

store current_balance

  


Compilers and Interpreters

  

-   A compiler is a program than turns a high-level language program into a machine-language program. (Then when one wants, once can execute the machine-language version.)
    

  

-   An interpreter is a program that executes the high-level program directly and translates it into machine language on the fly.




Some High Level Languages in Use Today

  

-   Fortran
    
-   Basic
    
-   PL/1
    
-   Cobol
    
-   C
    
-   C++
    
-   VISUAL BASIC
    

  

-   Pascal
    
-   LISP
    
-   ADA
    
-   JAVA
    
-   PHP
    
-   Python
    
-   Javascript
    





Interpreters vs. Compilers

  

-   Interpreters are easier to write than compilers.
    

  

-   Interpreter languages allow immediate editing and execution without the intermediate step of compiling.
    

  

-   Compiled code runs faster than interpreted code however so it is preferred in performance sensitive applications.
    

  

But this is slowly changing…..Why?






Simplifying The Translation

  

Matrix::Compute(double* values, int size) {  
  for(int i=0; i<size; i++) {  
      for(int j=0; j<size; j++) {  
        if(i<j && values[i*size+j]<0.0)  
            values[i*size+j] = values[j*size+i];  
        values[i*size+j] = 2*values[i*size+j];  
      }  
  }  
}

  

High-level language

  

Compiler

  

pushl %ebp  
movl %esp,%ebp  
movb hi_temp,%al  
addb lo_temp,%al  
movb $0,%ah  
adcb $0,%ah  
movb $2,%bl  
idivb %bl  
movb %al,av_temp  
leave  
ret

  

Assembly Language

  

Assembler

  

Machine Code

  

1001010101101011010101010010101010111101  
0000110101001110101011101011000110101001  
0011010101010101010101101111010101010100  
1111010101010101110101010101101110101011  
0110101101011101000101010000101010101100  
0100001010101010111110101010101011111111





Software Creation Process

  
  

-   Problem specification
    
-   Pseudocoding (or flowcharting)
    
-   Coding
    
-   Testing and debugging
    





Writing Software, the right way

  

-   Planning 10%
    
-   Design 30%
    
-   More Design 20%
    
-   Coding 20%
    

  

-   Testing 20%
    
-   Release
    


![Page-1](https://lh4.googleusercontent.com/iU_Mgtlb0f-YSkw00D7VLKOTpJX8MiExk5-CTaCBAeAvvI6KRtmNlS9FXfKwj0zU6EPNrFBFlttVMM91DGGvUn0wCkVCkP8a3hkPL8H07I5Ko_PaOgRgh12Mn_E5BNo-Wg5cRalvOOo2qQU=s2048)  

Flowcharting a design





Pseudo Code(ing)

  

-   Allows you to write a program in english for the purpose of design without having to worry about specific computer language syntax and allows the programmer to concentrate on the logical sequences
    

  

-   Start
    

-   Input (amount)
    
-   Amount = amount*4.33
    
-   If amount < 58 then print “It’s less than 58”
    
-   Else print “It’s over 58”
    
-   End
    






Python!

  

-   Python is a great language for learning basic elements of programming
    

  

-   Easy to understand syntax
    

  

-   Runs in an Interpreter for instant results!
    

  

-   Available for free at  [www.python.org](http://www.python.org/)
    

  

-   Runs on practically any computer!
    
-   We will use Python later in the course
    




Real world problem

  

A  real-world example is assigning gates at airports.  Some constraints are:

-   A plane that lands at time t1 should be assigned a gate for use at time t2 > t1.
    
-   If a plane is at a gate, no other plane may be assigned that gate, etc.
    
-   Find an assignment of gates that minimizes passenger time (and perhaps distance).
    




The Price of Failure

  

-   The opening of the new Denver Airport was delayed for almost one year in 1994!
    

  

-   The software which handled the routing of luggage from the gates to the various luggage carousels was so complex that it could not be fixed in time for the opening and the airport was two large to operate without it
    

  

-   The delay in opening cost over $1Million per day!
    



Quoted from the morning news

  

The morning news reported that the opening of Denver's new international airport would be delayed indefinitely until problems with the automated baggage handling system are fixed.

  

 While the video showed the machinery shredding open suitcases and throwing clothing all over the floor, the voice over of the airport director stated, "We think it's mostly a software problem."



Even 120 Computers couldn’t figure this out!  
A small portion of the Denver Conveyer System

![](https://lh5.googleusercontent.com/jVyGmlbcpC13NAi1gV3PH1HDPW-x2Dtu0VWaYOeDJwLznu7r0Ddpph8v9WFNg8uZfKOj5HI8lOZwbH4EyJtflHqk6xoVTJMp2HNgOfm9bYnyEZtBhcCK2CkYLUusxE-17nCCuakt68Pyv3A=s2048)

 

Complexity

  

-   Software is becoming more complex as we attempt to solve more complex  and difficult problems
    

  

-   Managing complexity is a huge problem in software reliability and cost
    

  

-   The problem is getting worse, not better as reflected in industry software issues worldwide
    


 


Cases in Complexity

  

Fred Brooks : Former IBM 360 Development Mgr

Wrote the famous “The Mythical Man Month” about the trials and tribulations of writing the Operating System for the IBM 360 in the 1960’s, at that time the most ambitious software project ever undertaken

  

Brook’s Law - Adding manpower to a late software project makes it later." 

  

Made the decision to put 8 bits in a byte instead of 6 which allowed upper and lower case characters to be accomodated

  

When on to found the CS Dept. at the Univ. of North Carolina

  
  
![225px-Fred_Brooks](https://lh3.googleusercontent.com/KhglVjzaOVNVOHdxFz3XNmi4VFKsNgpsTbhoomSl3FUxRnuV7NXf5iCs0CpchhsWHiHi1Ve6C8Uu6L_hCd0miP754hAATEiBihHm60BVHySYHtQyBvl15ZGB3-HXveAoeuNYFN_2L62qiis=s2048)




Some case studies in software disasters

  
  
  

[http://www.intertech.com/Blog/15-worst-computer-software-blunders/](http://www.intertech.com/Blog/15-worst-computer-software-blunders/)

  
  
  




### Creation Process

- Problem Specification - Planning 10%
- Pseudo coding - Design 30 %
- more Design 20 %
- Coding 20%
- Testing & Debugging 20%

### C++ workflow
#### Overview

![](https://www.learncpp.com/images/CppTutorial/Chapter0/Development-min.png?ezimgfmt=ng%3Awebp%2Fngcb2%2Frs%3Adevice%2Frscb2-1)


#### Step 1: Define the problem that you would like to solve

This is the “what” step, where you figure out what problem you are intending to solve. Coming up with the initial idea for what you would like to program can be the easiest step, or the hardest. But conceptually, it is the simplest. All you need is an idea that can be well defined, and you’re ready for the next step.

Here are a few examples

- “I want to write a program that will allow me to enter many numbers, then calculates the average.”
 
- “I want to write a program that generates a 2d maze and lets the user navigate through it. The user wins if they reach the end.”

 - “I want to write a program that reads in a file of stock prices and predicts whether the stock will go up or down.”

#### Step 2: Determine how you are going to solve the problem

This is the “how” step, where you determine how you are going to solve the problem you came up with in step 1. It is also the step that is most neglected in software development. The crux of the issue is that there are many ways to solve a problem -- however, some of these solutions are good and some of them are bad. Too often, a programmer will get an idea, sit down, and immediately start coding a solution. This often generates a solution that falls into the bad category.

Typically, good solutions have the following characteristics:

- They are straightforward (not overly complicated or confusing).
- They are well documented (especially around any assumptions being made or limitations).
- They are built modularly, so parts can be reused or changed later without impacting other parts of the program.
- They are robust, and can recover or give useful error messages when something unexpected happens.

When you sit down and start coding right away, you’re typically thinking “I want to do ``<something>``”, so you implement the solution that gets you there the fastest. This can lead to programs that are fragile, hard to change or extend later, or have lots of bugs (technical defects).

Studies have shown that only 20% of a programmer’s time is actually spent writing the initial program. The other 80% is spent on maintenance, which can consist of debugging (removing bugs), updates to cope with changes in the environment (e.g. to run on a new OS version), enhancements (minor changes to improve usability or capability), or internal improvements (to increase reliability or maintainability).

Consequently, it’s worth your time to spend a little extra time up front (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.

We’ll talk more about how to effectively design solutions to problems in a future lesson.


#### Step 3: Write the program

In order to write the program, we need two things: First, we need knowledge of a programming language -- that’s what these tutorials are for! Second, we need a text editor to write and save our written programs. The programs we write using C++ instructions are called source code (often shortened to just code). It’s possible to write a program using any text editor you want, even something as simple as Windows’ notepad or Unix’s vi or pico. However, we strongly urge you to use an editor that is designed for programming (called a code editor). Don’t worry if you don’t have one yet. We’ll cover how to install a code editor shortly.

A typical editor designed for coding has a few features that make programming much easier, including:

- Line numbering. Line numbering is useful when the compiler gives us an error, as a typical compiler error will state: some error code/message, line 64. Without an editor that shows line numbers, finding line 64 can be a real hassle.

- Syntax highlighting and coloring. Syntax highlighting and coloring changes the color of various parts of your program to    make it easier to identify the different components of your program. Here’s an example of a C++ program with both line numbering and syntax highlighting

- An unambiguous font. Non-programming fonts often make it hard to distinguish between the number 0 and the letter O, or between the number 1, the letter l (lower case L), and the letter I (upper case i). A good programming font will ensure these symbols are visually differentiated in order to ensure one isn’t accidentally used in place of the other. All code editors should have this enabled by default, but a standard text editor might not.

The programs you write will typically be named something.cpp, where something is replaced with the name of your choosing for the program (e.g. calculator, hi-lo, etc…). The .cpp extension tells the compiler (and you) that this is a C++ source code file that contains C++ instructions. Note that some people use the extension .cc instead of .cpp, but we recommend you use .cpp.

#### Step 4 : Compiling

Compiling your source code The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important tasks:

First, it checks your code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.

Second, it translates your C++ source code into a machine language file called an object file. Object files are typically named _name.o_ or _name.obj_, where _name_ is the same name as the .cpp file it was produced from.

![](https://www.learncpp.com/images/CppTutorial/Chapter0/CompileSource-min.png?ezimgfmt=rs:421x161/rscb2/ng:webp/ngcb2)

#### Step 5: Linking object files and libraries

After the compiler creates one or more object files, then another program called the linker kicks in. The job of the linker is three fold:

First, to take all the object files generated by the compiler and combine them into a single executable program.


![](https://www.learncpp.com/images/CppTutorial/Chapter0/LinkingObjects-min.png?ezimgfmt=rs:441x271/rscb2/ng:webp/ngcb2)

Second, in addition to being able to link object files, the linker also is capable of linking library files. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs.

The C++ core language is actually fairly small and concise (and you’ll learn much of it in these tutorials). However, C++ also comes with an extensive library called the C++ Standard Library (usually shortened to standard library) that provides additional functionality that you can use in your programs. One of the most commonly used parts of the C++ standard library is the iostream library, which contains functionality for printing text on a monitor and getting keyboard input from a user. Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.

You can also optionally link in other libraries. For example, if you were going to write a program that played sounds, you probably would not want to write your own code to read in the sound files from disk, check to ensure they were valid, or figure out how to route the sound data to the operating system or hardware to play through the speaker -- that would be a lot of work! Instead, you’d probably download a library that already knew how to do those things, and use that. We’ll talk about how to link in libraries (and create your own!) in the appendix.

Third, the linker makes sure all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.

Once the linker is finished linking all the object files and libraries (assuming all goes well), you will have an executable file that you can then run!

#### Steps 6 & 7: Testing and Debugging
Many (but not all) IDEs include a C++ compiler and a linker, IDEs typically bundle a number of other helpful editing features, such as integrated help, name completion, auto-formatting, and sometimes a version control system.

You should not be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).


#### makefile
For complex projects, some development environments use a **makefile**, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways). Entire books have been written about how to write and maintain makefiles, and they can be an incredibly powerful tool. However, because makefiles are not part of the C++ core language, nor do you need to use them to proceed, we’ll not discuss them as part of this tutorial series.
#### Build Options

- Build compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.

- Clean removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.
- Rebuild does a “clean”, followed by a “build”.

- Compile recompiles a single code file (regardless of whether it has been cached previously). This option does not invoke the linker or produce an executable.

- Run/start executes the executable from a prior build. Some IDEs (e.g. Visual Studio) will invoke a “build” before doing a “run” to ensure you are running the latest version of your code. Otherwise (e.g. Code::Blocks) will just execute the prior executable.

### Points of Compromise
#### Quality X Profit
(materials, parts)

#### Rechtlich

#### Design X Specs
(functionality, performance)
### Terms
#### Rule
Rules are instructions that you _must_ do, as required by the language. Failure to abide by a rule will generally result in your program not working.


#### Best practice
Best practices are things that you _should_ do, because that way of doing things is generally considered a standard or highly recommended. That is, either everybody does it that way (and if you do otherwise, you’ll be doing something people don’t expect), or it is superior to the alternatives.


#### Warning
Warnings are things that you _should not_ do, because they will generally lead to unexpected results.

## Best practices
### General
#### Programs
```
Programs

Programs are collections of instructions that manipulate data to produce a desired result.

A computer program is a sequence of instructions that tell the computer what to do. A statement is a type of instruction that causes the program to perform some action.

1. Declaration statements
2. Jump statements
3. Expression statements
4. Compound statements
5. Selection statements (conditionals) 
6. Iteration statements (loops)
7. Try blocks

A function is a collection of statements that get executed sequentially (in order, from top to bottom)

Every C++ program must have a special function named main (all lower case letters). When the program is run, the statements inside of main are executed in sequential order.

When discussing functions, it’s fairly common shorthand to append a pair of parenthesis to the end of the function’s name. For example, if you see the term main() or doSomething(), this is shorthand for functions named main or doSomething respectively. This helps differentiate functions from other things with names (such as variables) without having to write the word “function” each time.

A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs

In general programming, the term object typically refers to an unnamed object in memory, a variable, or a function. In C++, the term object has a narrower definition that excludes functions.

Use the debug build configuration when developing your programs. When you’re ready to release your executable to others, or want to test performance, use the release build configuration.

Whenever you update your project settings, make the change for all build configurations (unless it’s not appropriate for some reason).
```

```F7 (if this doesn’t work, try Ctrl-Shift-B) or go to the Build menu > Build Solution```

```To run your compiled program, press Ctrl-F5, or go to the Debug menu and choose Start Without Debugging```

    c++1x = C++11
    c++1y = C++14
    c++1z = C++17
    c++2a = C++20
    c++2b = C++23


```
We recommend choosing the latest standard “ISO C++ Latest (/std:c++latest)”, which will ensure you can use as many features as your compiler supports.

Make sure you’re selecting the language standard from the dropdown menu (don’t type it out).

In Visual Studio, this option is available via Project -> Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.

Next time you create a new project, you’ll see this template show up in your list of project templates.

Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -> <Project Name> -> Source Files -> <template name>.cpp.
````

### Coding
#### Comments
```
Don’t use multi-line comments inside other multi-line comments. Wrapping single-line comments inside a multi-line comment is okay.

First, for a given library, program, or function, comments are best used to describe _what_ the library

Second, _within_ a library, program, or function described above, comments can be used to describe _how_ the code is going to accomplish its goal.

Finally, comments should be written in a way that makes sense to someone who has no idea what the code does. It is often the case that a programmer will say “It’s obvious what this does! There’s no way I’ll forget about this”

Comment your code liberally, and write your comments as if speaking to someone who has no idea what the code does. Don’t assume you’ll remember why you made specific choices.
Don’t use multi-line comments inside other multi-line comments. Wrapping single-line comments inside a multi-line comment is okay.

```




#### Formatting
```
Consider keeping your lines to 80 chars or less in length.

Many editors have a built-in feature (or plugin/extension) that will show a line (called a “column guide”) at a given column (e.g. at 80 characters), so you can easily see when your lines are getting too long. To see if your editor supports this, do a search on your editor’s name + “Column guide”.

When working in an existing program, use the conventions of that program (even if they don’t conform to modern best practices). Use modern best practices when you’re writing new programs.

It’s worth noting that if you’re working in someone else’s code, it’s generally considered better to match the style of the code you are working in than to rigidly follow the naming conventions laid out above.


```

```
Warning

With Visual Studio, you will need to reselect your language standard every time you create a new project.
```



#### New Line
```
Output a newline whenever a line of output is complete.

‘\n’ uses a backslash (as do all special characters in C++), not a forward slash. Using a forward slash (e.g. ‘/n’) instead may result in unexpected behavior.



Prefer ‘\n’ over std::endl when outputting text to the console.

std::endl isn’t technically necessary, since the program ends immediately afterward. However, it serves a few useful purposes.

First, it helps indicate that the line of output is a “complete thought” (as opposed to partial output that is completed somewhere later in the code). In this sense, it functions similarly to using a period in standard English.

Second, it positions the cursor on the next line, so that if we later add additional lines of output (e.g. have the program say “bye!”), those lines will appear where we expect (rather than appended to the prior line of output).

Third, after running an executable from the command line, some operating systems do not output a new line before showing the command prompt again. If our program does not end with the cursor on a new line, the command prompt may appear appended to the prior line of output, rather than at the start of a new line as the user would expect.

```

#### Initialization
```
Although the language allows you to do so, avoid defining multiple variables of the same type in a single statement. Instead, define each variable in a separate statement on its own line (and then use a single-line comment to document what it is used for).

Copy initialization is also used whenever values are implicitly copied or converted, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.

Prior to the introduction of list initialization, some types of initialization required using copy initialization, and other types of initialization required using direct initialization. List initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called “uniform initialization”) that works in most cases.

Additionally, list initialization provides a way to initialize objects with a list of values (which is why it is called “list initialization”).

Favor initialization using braces.

There’s some debate over whether it’s necessary to initialize a variable immediately before you give it a user provided value via another source (e.g. std::cin), since the user-provided value will just overwrite the initialization value. In line with our previous recommendation that variables should always be initialized, best practice is to initialize the variable first.

```



#### Literals
```
Literals are values that are inserted directly into the source code. These values usually appear directly in the executable code (unless they are optimized out).

Objects and variables represent memory locations that hold values. These values can be fetched on demand.
```




#### Operators
```
You are likely already quite familiar with standard arithmetic operators from common usage in mathematics, including addition (+), subtraction (-), multiplication (*), and division (/). In C++, assignment (=) is an operator as well, as are insertion (<<), extraction (>>), and equality (==). While most operators have symbols for names (e.g. +, or ==), there are also a number of operators that are keywords (e.g. new, delete, and throw).
For operators that are symbols, it is common to append the operator’s symbol to the word operator.

For example, the plus operator would be written operator+, and the extraction operator would be written operator>>.

Parenthesis first, then Exponents, then Multiplication & Division, then Addition & SubtractionPEMDAS, or expanded to the mnemonic “Please Excuse My Dear Aunt Sally”.

In some countries, PEMDAS is taught as PEDMAS, BEDMAS, BODMAS, or BIDMAS instead.

```



#### Buffer
```
Buffered systems are often used in cases where processing a few large batches of data is more efficient than processing many smaller batches of data. Buffering maximizes overall throughput, at the cost of increasing response time.

To use another analogy, flushing a buffer is kind of like flushing a toilet. All of your collected “output” is transferred to … wherever it goes next. Eew.
```

#### Undefined Behaviour
```
Your program produces different results every time it is run.
Your program consistently produces the same incorrect result.
Your program behaves inconsistently (sometimes produces the correct result, sometimes not).
Your program seems like it’s working but produces incorrect results later in the program.
Your program crashes, either immediately or later.
Your program works on some compilers but not others.
Your program works until you change some other seemingly unrelated code.

Undefined behavior is like a box of chocolates. You never know what you’re going to get!

Take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.

Avoid implementation-defined and unspecified behavior whenever possible, as they may cause your program to malfunction on other implementations.
```

````cpp
#include <iostream>
int main()
{
	std::cout << sizeof(int); // print how many bytes of memory an int value takes

	return 0;
}
````





#### Debug

```C/C++ > Language tab, and set Conformance mode to Yes (/permissive-) ```

```C/C++ > Command Line tab, under Additional Options, add /w44365```

```C/C++ > External Includes tab, set External Header Warning Level to Level3 (/external:W3)```

```C/C++ > General tab and set Treat Warnings As Errors to Yes (/WX)```

```
Use the debug build configuration when developing your programs. When you’re ready to release your executable to others, or want to test performance, use the release build configuration.

Disable compiler extensions to ensure your programs (and coding practices) remain compliant with C++ standards and will work on any system.

Don’t let warnings pile up. Resolve them as you encounter them (as if they were errors). Otherwise a warning about a serious issue may be lost amongst warnings about non-serious issues.

Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues.
Do not choose EnableAllWarnings (/Wall) or you will be buried in warnings generated by the C++ standard library.

Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings.
```

##### Workaround
```cpp
#include <iostream>
#include <limits>
```

Second, add the following code at the end of the main() function (just before the return statement):

```cpp
std::cin.clear(); // reset any error flags
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any characters in the input buffer until we find a newline
std::cin.get(); // get one more char from the user (waits for user to press enter)
```

```system("pause")```






# Learning
## Concepts
### the _ellipsis_ (also known as _…_) 
where a necessary or non-obvious part of an example is omitted in the interest of space
### the _unexplained new concept_, 
where a new concept that is integral to the example is introduced without any mention of what it is or how it works. 

Both of these tend to lead to getting stuck.


#### Unsorted 
No descriptive statistic is ever perfect. What matters is that it is useful.

Graphics is full of procedural methods for texture, geometry, etc. which are all good candidates for machine
learning (good research topics)

Helpful Hint: Always compute composite transforms for objects or sub-objects, and apply the
single composite transform to all relevant points (it’s a lot faster)
• Helpful Hint: Orientation is best done first:
• Place the object at the centre of the target coordinate system, and rotate it into the desired orientation
• Afterwards, translate the object to the desired location

if you apply a tool, technique, or resource from another book, web page, or article and it doesn't look right, try flipping the sign on the -axis. 

## What does a computer do?

-   Computers internally just keep doing the same thing over and over:
    
-   Get the next instruction
    
-   Do whatever it says
    
-   Go back to step #1  
      
    
-   But its internal instructions are in binary -- too hard for people to understand easily
    
![merrygoround](https://lh4.googleusercontent.com/jt40q1xjCObnPIKHGl5sGIAi43u6FRvPBO6p98GuSFAEZkdO3BeofuCkeGBI6cF84x6pPkWJ7LtUfZ5-BZYFy7m5XPbDWDOafb9q9nhstspq59P5SJlk9k0hK3uBwwQ3BkQbBBnWzkIWzd0=s2048)  

## Formal Languages

-   A program usually just a document -- a written list of instructions
    
-   You saw some of this with HTML -- A markup language is sort-of a programming language
    
![tuxedo](https://lh6.googleusercontent.com/TwrB6O77DvvWtUy-lpHw6ykNd-YczHcduRuWyXTp3CsqXeNhHgyUMym8OwvpEjdZUBwitzsiaS7fxmZUvvVC1B-IslJRitac5HmMAetzMn3VxVV9Sh5vEHf3T2CObFQU3oJbm9LQiyv0pGE=s2048)  

Poetry: Ambiguity and metaphor are important
Prose: Literalness and structure important

## Program: Formal, precise structure

![robot](https://lh3.googleusercontent.com/POmUh5VFcXeq6rw8nf1aJ5b3IjPrzc_qVkG8GgMelMjLGUXKUHKM3Rltv8uzN3A0fAOBVbHpcqKTdX04FAM9qa-ApbwWgmhaiJAysi9efrYg35IQ9SExqKnePIbl5Y4xhzIhdgt29c29_bc=s2048)  

PB&J
Robot…

## Programming Languages
![progpang](https://lh4.googleusercontent.com/6zjFP2ZDHOYjY2MP1U9oGz8Bbpfw4mUnSLfFwvxWcs3NK2gzE13dyNNKC2rPHOpG7W8WTeh4nPXE2cBai4ILG6xpQ7-v1infqMUTBL9WMBhwdqB4egMLy7vqCv2ygWNTLL62mEqedn1zMGc=s2048)  

-   Some simple ones are built in to programs you use every day
    
-   Excel is a programming language (and contains another)
    
-   Word Macro Language
    
-   There are also General Purpose Programming Languages
    
## Pseudocode

-   There are lots of details to programming languages
    
-   We’ll also use something called “pseudocode”
    
-   Most of the way to a programming language
    
-   Excludes some details
    
-   With some plain English mixed in
    
## Some Core Concepts

-   (A quick taste of what you'll be learning in Python)
    
-   State
    
-   Expressions
    
-   Variables
    
-   Control
    
![python](https://lh3.googleusercontent.com/_B8CEwXBWpGEOiN_sylDGmMxPiEqnzXDG-fmntazupCGIGDjev-tFzq7irg6Y6zR-s64l233IlkN06w4A20lfx1c4OaKak_TggSAMXxwQyfzAMvf1E4aLGsGvgAAERats8WCYf2IsN0B8Jk=s2048)  

## State
![chessboard](https://lh6.googleusercontent.com/hgEFp-TGT32OVCjyMEMTgVGQ-cMjfTdNgZfyXljUyS782HmFv9bRf6bTgdSWmvgOoT5t0RaY-m3Ym2q-zzWXdNrZpTeeKM-0H5PcbdJrU1y3OjGNd7kapcE0_d-DMZ_idyTED31FlRUKD8I=s2048)  
![faces](https://lh4.googleusercontent.com/w9MelqLCcaMyaYJzC4b-GQkeM9JMqlJBNskzhLNG0WW4gfh1jD9a9y9dK3ewUuPyJhdJ3F3qFKBQ_g7nHlmAox5wNTKxKQewh5AtHEBmjN61hVJZkyQE4HroM4wJu0O-rgb36Y7zB-e0nOk=s2048)  

## Expressions

> print “Hello”

  Hello

> print (5+3)  
8

>print (5*5-2)  
23

## Variables

-   Not exactly like Algebra
    
-   In Algebra x=5 (or 5=x) expresses a truth
    
-   In a program, x=5 updates something in the computer’s memory
    
-   (and 5=x wouldn’t work: it’s not a valid statement)
    
## Control Structures

-   Lets you make decisions
    
-   for, while, …
    
if(x>5):

   print (“x is big”)

Else:

   print (“x is small”)

## Programs

 “The computer programmer is a creator of universes for which he alone is responsible. Universes of virtually unlimited complexity can be created in the form of computer programs.”

![escher](https://lh5.googleusercontent.com/dvUuJNEvhNdipLWW1b-Wz1DAuYCCfUv7S3bJiB0MnOpmH4WVcNzjaa_P4_q0vXpBLejiTpoV9kjZxj-3s7SJBULn-pRmowfP0dzgrm83W-Y5eb9QToJy6sXB_a9KAekk3Eidu3J0Cni4wXU=s2048)  

## Complexity

Controlling complexity is the essence of computer programming

-Brian Kernigan   
  
## The Process

![nterpreter](https://lh5.googleusercontent.com/uzi4GLrSnCOzVkduLexwqyZeVeAGncs8is6w0ikMrJ-VOCUaKgFbp8OwmajGBxPaAaleRXQA0ZjPo5PigfVmIhF4DLLOSjyK5jmW5cfGU6WoA0RxuORHpq56vO-Ql4fOzRHUv2IC8GvXCq4=s2048)  

## But what do you DO?

-   Design
    
-   Requirements
    
-   Use cases
    
-   Pseudocode
    
-   Formal Code
    
-   Test
    
-   Debug
    
![working](https://lh5.googleusercontent.com/pr4wNqcPcjxv1DoH6T7e0zr2bfzRf9mr_42a9MBexGLUueJnsjPHRGRn_P-zaUbbkj_5QuH0aSeKrtIl1XHVf4kgIuj1qTfOylviRwyesee-ZgzoEi2TgGsvk57eVzVDKdIIKbugYxpIW8s=s2048)  

## Design

-   Most programming is not done sitting in front of a computer
    
-   You need to really understand what the program will do
    
-   How it interacts with the user
    
-   And how it is structured internally
    
![thinker](https://lh4.googleusercontent.com/D76SXAy9opE7DGhf-U-RghP9joy4z4hlloN1432KCSQq1g7-ceo6ieHe6QbdMPaV7wdAx-bmTlMJp8FEFUz-KJ4yDJ40MNl6k4calps1Le3_993m74t5iK-w67qmekptn9bNbqdj9k4adKo=s2048)  

Mostly, when you see programmers, they aren't doing anything. One of the attractive things about programmers is that you cannot tell whether or not they are working simply by looking at them. Very often they're sitting there seemingly drinking coffee and gossiping, or just staring into space. What the programmer is trying to do is get a handle on all the individual and unrelated ideas that are scampering around in his or her head.  
  
Charles M Strauss   

## Test

-   Testing a complicated program is difficult
    
-   Some people write the tests before the programs
    

 “Programming is like sex, one mistake and you have to support it for the rest of your life.”

## Debug

-   At the beginning, much of your time
    
-   In many ways more challenging than coding
    
-   When you have eliminated the impossible, whatever remains, however improbable, must be the truth. – Sherlock Holmes
    
![sherlock](https://lh5.googleusercontent.com/ONX54ZPwh0H02CE3YrAf6JWtxocP8qJ0ke4z0oibHYgWXdIm-0eKifhwLEzLDu8QApjd9lVei-9g0BGmziNUeCsLLzue1qazh4AOXhqPJtMFajOr65YhkZexV1lFGrX73jJELyfc65cXQI4=s2048)  

## What is Python?

-   A REAL Programming Language!
    
-   Developed in 1990 by Guido Van Rossum in the Netherlands
    
-   Named after Monte Python’s Flying Circus!
    
-   Openly available at no charge!
    
-   Freely distributed on the Web
    
-   Lot’s of Libraries of Python Routines available
    
-   Increasingly popular for writing scripts for the Web
    
## How does Python work?

-   It is an INTERPRETED Language, (Like HTML and Java) so that it is easy to write and execute programs in an interactive mode
    
-   It has a very clear and easy Syntax
    
-   It is portable so it  runs on many different Operating Systems and Machines (Windows, MacOS, Linux, Unix, etc)
    
## What are we going to do with Python in CS2?

-   Learn some basic commands and capabilities of the language
    
-   Printing data, evaluating expressions, inputting data, variables, loops, decisions, functions, boolean expressions
    
-   Learn how to use the programming environment
    
-   Learn how to write simple but useful programs
    
## What tools will you require?

-   You will need the Python  Interpreter and programming environment
    
-   Already installed on the computers in the LAB
    
-   Can be downloaded and installed  on your personal machine from:
    
-   [www.python.org](http://www.python.org/)
    
-   Hint…to be safe install the 32 bit version for your OS
    
-   You will need the Python Tutorial
    
## General Conventions

-   Python is Case Sensitive!…Be Careful!
    
-   Anything you name (variables, etc) must be referred to exactly as initially typed
    
-   Python Commands are always in lowercase!
    
-   Comments can be inserted anywhere by using a “#” before the comment text
    
-   Some commands require indentation to work properly
    
## Variables
  
-   You can think of variables as labeled jars that store different types of data. While there are several kinds of variables, today we're only going to look at two:
    

## String Variables

-   Strings are literal collections of text characters
    
-   Strings must be enclosed in either single or double quotes
    
-   Strings may be manipulated by a variety of operators (repetition, concatenation, etc)
    
-   Concatenation example
    
-   word = “abc”
    
-   word = word + “def”
    
-   print (word) you will get:     abcdef
    
## More String Operations

-   String Repetition
    
-   word = “Yo! ”
    
-   print (word* 5)
    
-   Results in   Yo!Yo!Yo!Yo!Yo!
    
## String Variables

-   String - A string variable is a string of alphanumeric characters and allowed symbols that are contained within quotation marks. For example, "Hello world, I'm 102 years old today!" is an example of a string. 
    
-   Strings are basically used for storing text
    
-   Example:  greeting = “Good Morning Sunshine!”
    
## Number Variables

-   Number - A number variable couldn't be more straightforward because all number variables store are numbers. You don't store them within quotes like strings. Instead, numbers can just be written as they are. If you want to store the number 9 in a variable, you just write 9
    
-   Example:  my_bank_balance = 9
    
or….    pi=3.14

## Our First Program

-   A program that prints a greeting!
    
-   print (“Hello, World!”)
    
-   When this program runs, it outputs…          Hello, World!
    
-   The text inside of the quotes in the program is referred to as a String, or String Variable
    

## Another way to achieve the same  

result
-   greeting = “Hello, World!”
    
-    print (greeting)
    
-   The output is     Hello, World!
    
-   Note that we assigned the variable name greeting with the value of the literal string inside of the quotes.
    
## Expressions 

-   Another more complicated program:
    
-   print (“2 plus 2 is”, 2+2)
    
-   print (“3 times 3 is”, 3*3)
    
-   print (“35 divided by 5 is”, 35/5)
    
-   The output will be: 2 plus 2 is 4 3 times 3 is 9 35 divided by 5 is 7
    
## Operations on Numbers

-   Operation Symbol Example
    
-   Exponentiation      5  2 == 25
    
-   Multiplication       * 2 * 3 == 6
    
-   Division                 / 14 / 3 == 4                                                14 / 3.0 == 4.6666
    
-   Remainder       %     14 % 3 == 2
    
-   Addition                 +      1 + 2 == 3
    
-   Subtraction          -     4 - 3 == 1
    
## More Variable Assignment Examples

-   value = 4*8
    
-   net_price =4.56
    
-   repeat_word = “word” * 5 
    
-   Variables are created and recognized dynamically, that is when they appear in your program with a value assigned to them
    
-   Variables must be assigned before you refer to them otherwise an error will occur
    
-   The values that are assigned to variables in Python are called Objects, each object having a reserved place in memory with a pointer connecting it to the assigned variable
    
## Variable manipulation

-   Variables can be used in conjunction with themselves to affect certain operations;
    
-   Example:
    
-   speed=3
    
-   speed=speed+4
    
-   speed=speed*3
    
-   print (speed)      
    
-   WHAT is the output of this program?   

## Printing variables

-   Variables may be printed by themselves or in succession
    
-   Example
    
number = 9

bignumber = 55

print (number)

print (bignumber)

print (number ,  bignumber)

(puts them on the same line)

## Inputting Data into your program

-   We will focus on user input which is the simplest type and suitable for our purposes
    
-   Input command syntax is:
    
speed = input (“enter speed “)                 

Ok, so let’s write a simple program with the stuff that we have covered so far

-   # A simple program to check our travel progress
    
-   name = input ("enter your name: ")
    
-   speed = int(input("enter your average speed: "))
    
-   time =  int(input("enter your exact travel time in hours: "))
    
-   print (name + " your distance travelled is exactly ",speed*time, " miles")
    
-   print ("the end")
    
 “That's what's cool about working with computers. They don't argue, they remember everything and they don't drink all your beer.” 














