

# Paradigma
https://de.wikipedia.org/wiki/Paradigma

Ein **Paradigma**[[1]](https://de.wikipedia.org/wiki/Paradigma#cite_note-1) ([Plural](https://de.wikipedia.org/wiki/Plural "Plural") _Paradigmen_ oder _Paradigmata_) ist eine grundsätzliche Denkweise.


In der antiken [Rhetorik](https://de.wikipedia.org/wiki/Rhetorik "Rhetorik") verstand man darunter eine Begebenheit, die als positiver oder negativer Beleg für eine [dogmatische](https://de.wikipedia.org/wiki/Dogmatik "Dogmatik") Argumentation oder eine [Morallehre](https://de.wikipedia.org/wiki/Moral "Moral") angeführt wird.[[2]](https://de.wikipedia.org/wiki/Paradigma#cite_note-2) Seit dem späten 18. Jahrhundert bezeichnete Paradigma eine bestimmte Art der [Weltanschauung](https://de.wikipedia.org/wiki/Weltanschauung "Weltanschauung") oder eine [Lehrmeinung](https://de.wikipedia.org/wiki/Lehrmeinung "Lehrmeinung"). Der Begriff wurde von [Georg Christoph Lichtenberg](https://de.wikipedia.org/wiki/Georg_Christoph_Lichtenberg "Georg Christoph Lichtenberg") eingebracht.[[3]](https://de.wikipedia.org/wiki/Paradigma#cite_note-3) Nach [Ludwig Wittgenstein](https://de.wikipedia.org/wiki/Ludwig_Wittgenstein "Ludwig Wittgenstein") sind Paradigmen Muster oder Standards, mit denen Erfahrung verglichen und beurteilt wird. Sie liegen vor der Erfahrung ([a priori](https://de.wikipedia.org/wiki/A_priori "A priori")) und geben eine Orientierung vor.

„Ein Wissenschaftsparadigma ist ein einigermaßen zusammenhängendes, von vielen Wissenschaftlern geteiltes Bündel aus theoretischen Leitsätzen, Fragestellungen und Methoden, das längere historische Perioden in der Entwicklung einer Wissenschaft überdauert.“

_Die Struktur wissenschaftlicher Revolutionen_ ein „wissenschaftliches Paradigma“ als:[[4]](https://de.wikipedia.org/wiki/Paradigma#cite_note-:0-4)

-   das, was beobachtet und überprüft wird
-   die Art der Fragen, welche in Bezug auf ein Thema gestellt werden und die geprüft werden sollen
-   wie diese Fragen gestellt werden sollen
-   wie die Ergebnisse der wissenschaftlichen Untersuchung interpretiert werden sollen

++++++++++add more++++++++++++++++++++






# Programmierparadigma


Ein **Programmierparadigma** ist ein fundamentaler [Programmierstil](https://de.wikipedia.org/wiki/Programmierstil "Programmierstil").[[1]](https://de.wikipedia.org/wiki/Programmierparadigma#cite_note-Stroustrup-1) „Der [Programmierung](https://de.wikipedia.org/wiki/Programmierung "Programmierung") liegen je nach Design der einzelnen Programmiersprache verschiedene Prinzipien zugrunde. Diese sollen den Entwickler bei der Erstellung von ‚gutem Code‘ unterstützen, in manchen Fällen sogar zu einer bestimmten Herangehensweise bei der Lösung von Problemen zwingen“.[](https://de.wikipedia.org/wiki/Programmierparadigma#cite_note-GKIT-2)


Programmierparadigmen unterscheiden sich durch ihre Konzepte für die Repräsentation von statischen (wie beispielsweise [Objekte](https://de.wikipedia.org/wiki/Objekt_(Programmierung) "Objekt (Programmierung)"), [Methoden](https://de.wikipedia.org/wiki/Methode_(Programmierung) "Methode (Programmierung)"), [Variablen](https://de.wikipedia.org/wiki/Variable_(Programmierung) "Variable (Programmierung)"), [Konstanten](https://de.wikipedia.org/wiki/Konstante_(Programmierung) "Konstante (Programmierung)")) und dynamischen (wie beispielsweise [Zuweisungen](https://de.wikipedia.org/wiki/Zuweisung "Zuweisung"), [Kontrollfluss](https://de.wikipedia.org/wiki/Kontrollstruktur "Kontrollstruktur"), [Datenfluss](https://de.wikipedia.org/wiki/Datenfluss "Datenfluss")) Programmelementen.

Grundlegend für den [Entwurf](https://de.wikipedia.org/wiki/Entwurf "Entwurf") von [Programmiersprachen](https://de.wikipedia.org/wiki/Programmiersprache "Programmiersprache") sind die [Paradigmen](https://de.wikipedia.org/wiki/Paradigma "Paradigma") der _imperativen_ und der _deklarativen_ Programmierung. Beim letzteren sind als wichtige Ausprägungen die Paradigmen der [funktionalen Programmierung](https://de.wikipedia.org/wiki/Funktionale_Programmierung "Funktionale Programmierung") und der [logischen Programmierung](https://de.wikipedia.org/wiki/Logische_Programmierung "Logische Programmierung") zu nennen.

Die verschiedenen Paradigmen sind, bezogen auf einzelne [Computerprogramme](https://de.wikipedia.org/wiki/Computerprogramm), nicht als konkurrierende bzw. alternative Programmierstile zu verstehen. Vielmehr können „viele Programmiersprachen mehrere Paradigmen gleichzeitig unterstützen“.

Beispiel

In einer unter [MS Access](https://de.wikipedia.org/wiki/Microsoft_Access) und mit [VBA](https://de.wikipedia.org/wiki/Visual_Basic_for_Applications "Visual Basic for Applications") entwickelten [Anwendung](https://de.wikipedia.org/wiki/Anwendungssoftware "Anwendungssoftware") sind die funktionalen Komponenten _ereignis- und objektorientiert_ angelegt (Bsp.: „beim Öffnen von Formular X“). Der VBA-Code ist _strukturiert/modular/prozedural_ (denn er besteht aus Modulen, Makros, Prozeduren etc.); und er ist gleichzeitig _imperativ_, weil er „Befehle“ enthält, die (innerhalb der Prozeduren…) exakt in der codierten Folge ausgeführt werden. Formulare und Berichte sowie die [SQL](https://de.wikipedia.org/wiki/SQL "SQL")-Aufrufe sind _deklarativ_, weil der Entwickler hier nur das WAS und nicht das WIE festlegt.

Trotzdem werden Programmiersprachen häufig – nach ihrer Grund-Charakteristik – z. B. als objektorientierte, prozedurale oder deklarative Sprache bezeichnet. Die ein Paradigma bestimmenden Merkmale beruhen überwiegend auf den Eigenschaften der angewendeten _Programmiersprachen_ (wie z. B. bei [OOP](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung "Objektorientierte Programmierung"), deklarativ …), zum Teil aber auch auf dem individuellen _Stil_, der beim Programmieren praktiziert wird (z. B. strukturiert, modular).

Oft kann an den „Bürgern erster Klasse“ („First Class Citizens“ – FCCs) einer Programmiersprache – also den Formen von Daten, die direkt verwendet werden können – erkannt werden, welchem Paradigma die Sprache gehorcht. In [Java](https://de.wikipedia.org/wiki/Java_(Programmiersprache) "Java (Programmiersprache)") (objektorientiert) zum Beispiel sind Objekte FCCs, in [Lisp](https://de.wikipedia.org/wiki/Lisp "Lisp") ist jedes Stück Programm FCC, in [Perl](https://de.wikipedia.org/wiki/Perl_(Programmiersprache) "Perl (Programmiersprache)") sind es Zeichenketten, Arrays und Hashes.


# Imperative Programmierung

Bei der imperativen Programmierung „besteht ein [Programm](https://de.wikipedia.org/wiki/Computerprogramm "Computerprogramm") (Anm.: d. h. hier der [Quellcode](https://de.wikipedia.org/wiki/Quellcode "Quellcode")) aus einer Folge von Befehlen, die vorgeben, in welcher Reihenfolge was vom Computer getan werden soll“.[[2]](https://de.wikipedia.org/wiki/Programmierparadigma#cite_note-GKIT-2) Die Bezeichnung basiert auf lateinisch „imperare“ („anordnen“, „befehlen“).

> „Die meisten […] Programmiersprachen, darunter auch [OOP](https://de.wikipedia.org/wiki/Objektorientierte_Programmiersprache "Objektorientierte Programmiersprache")-Sprachen wie C#, Visual Basic, C++ und Java, unterstützen in erster Linie [auch] die imperative […] Programmierung.“[[3]](https://de.wikipedia.org/wiki/Programmierparadigma#cite_note-MSLIB-3)


# Strukturierte Programmierung

Eine Weiterentwicklung imperativer Sprachen markierte der Aufsatz _Go To Statement Considered Harmful_ von [Edsger W. Dijkstra](https://de.wikipedia.org/wiki/Edsger_W._Dijkstra "Edsger W. Dijkstra") aus dem Jahr 1968. Darin wird der Verzicht oder zumindest die Einschränkung der absoluten [Sprunganweisungen](https://de.wikipedia.org/wiki/Sprunganweisung "Sprunganweisung") (Goto) gefordert; stattdessen sollen [Kontrollstrukturen](https://de.wikipedia.org/wiki/Kontrollstruktur "Kontrollstruktur"), wie zum Beispiel „if… then…“, „case… of…“, „while… do…“, „repeat… until…“ verwendet werden.

# Prozedurale Programmierung

Den Ansatz, Programme in kleinere Teilaufgaben aufzuspalten, bezeichnet man als prozedurale Programmierung. Die entstehenden Teilprogramme werden [Prozeduren](https://de.wikipedia.org/wiki/Prozedur_(Programmierung) "Prozedur (Programmierung)") genannt. Praktisch alle aktuellen imperativen Programmiersprachen beinhalten den prozeduralen Ansatz.

Die Entwicklung prozeduraler Programmiersprachen und -techniken waren ein wesentlicher Schritt zwischen [Assemblersprache](https://de.wikipedia.org/wiki/Assemblersprache "Assemblersprache") und [Hochsprachen](https://de.wikipedia.org/wiki/H%C3%B6here_Programmiersprache "Höhere Programmiersprache"), indem sie [Abstraktion](https://de.wikipedia.org/wiki/Abstraktion "Abstraktion") und Zerlegung von Algorithmen ermöglichen.


# Modulare Programmierung

Modulare Programmierung war der erste Versuch, der wachsenden Größe von [Softwareprojekten](https://de.wikipedia.org/wiki/Softwareprojekt "Softwareprojekt") Herr zu werden. In der modularen Programmierung wird der prozedurale Ansatz erweitert, indem Prozeduren zusammen mit Daten in [logischen Einheiten](https://de.wikipedia.org/wiki/Datenkapselung_(Programmierung) "Datenkapselung (Programmierung)") zusammengefasst werden. Die Software wird so in größere funktionale Teilblöcke zerlegt, die einzeln geplant, [programmiert](https://de.wikipedia.org/wiki/Programmieren "Programmieren") und [getestet](https://de.wikipedia.org/wiki/Softwaretest "Softwaretest") werden können. Die entstehenden Unterprogramme werden als [Module](https://de.wikipedia.org/wiki/Modul_(Software) "Modul (Software)") bezeichnet. Am Ende können die Einzelteile dann logisch miteinander verknüpft werden und die Software ist einsatzbereit. Die [normierte Programmierung](https://de.wikipedia.org/wiki/Normierte_Programmierung "Normierte Programmierung") beschreibt dabei den Versuch, diesen Ablauf zu standardisieren. Die erste streng modularisierte Programmiersprache war 1978 [Modula-2](https://de.wikipedia.org/wiki/Modula-2 "Modula-2").


# Abstrakte Datentypen

Die Programmierung mit _abstrakten Datentypen_ behandelt Daten und Funktionen zur Behandlung dieser Daten als Einheit.
# Deklarative Programmierung

Die Idee einer deklarativen Programmierung ist der historisch jüngere Ansatz. Im Gegensatz zu imperativen Programmierparadigmen, bei denen das _Wie_ im Vordergrund steht, fragt man in der deklarativen Programmierung nach dem _Was_, das berechnet werden soll. Es wird also nicht mehr der Lösungsweg programmiert, sondern nur noch angegeben, welches Ergebnis gewünscht ist. Zu diesem Zweck beruhen deklarative Paradigmen auf mathematischen, rechnerunabhängigen Theorien.

-   Aufgrund der [referenziellen Transparenz](https://de.wikipedia.org/wiki/Referenzielle_Transparenz "Referenzielle Transparenz") gibt es keine [Nebeneffekte](https://de.wikipedia.org/wiki/Wirkung_(Informatik) "Wirkung (Informatik)"). Programme sind damit teilweise auswertbar und ermöglichen so zum Beispiel die Behandlung unendlicher Datenstrukturen.
-   Beweise (zum Beispiel Korrektheitsbeweis, Beweise über Programmeigenschaften) sind dank mathematischer Basis (unter anderem [Lambda-Kalkül](https://de.wikipedia.org/wiki/Lambda-Kalk%C3%BCl "Lambda-Kalkül")) uneingeschränkt durchführbar.
-   Architekturunabhängigkeit
-   teilweise geringe Akzeptanz (man spricht gern von sogenannten Akademikersprachen)

Zu den deklarativen Programmiersprachen gehören:

-   [funktionale Sprachen](https://de.wikipedia.org/wiki/Funktionale_Programmierung "Funktionale Programmierung") (unter anderem [Lisp](https://de.wikipedia.org/wiki/Lisp "Lisp"), [ML](https://de.wikipedia.org/wiki/ML_(Programmiersprache) "ML (Programmiersprache)"), [Miranda](https://de.wikipedia.org/wiki/Miranda_(Programmiersprache) "Miranda (Programmiersprache)"), [Gofer](https://de.wikipedia.org/wiki/Gofer "Gofer"), [Haskell](https://de.wikipedia.org/wiki/Haskell_(Programmiersprache) "Haskell (Programmiersprache)"), [F#](https://de.wikipedia.org/wiki/F-Sharp "F-Sharp"), [Scala](https://de.wikipedia.org/wiki/Scala_(Programmiersprache) "Scala (Programmiersprache)"))
-   [logische Sprachen](https://de.wikipedia.org/wiki/Logische_Programmierung "Logische Programmierung") (unter anderem [Prolog](https://de.wikipedia.org/wiki/Prolog_(Programmiersprache) "Prolog (Programmiersprache)"))
-   funktional-logische Sprachen (unter anderem Babel, Escher, Curry, [Oz](https://de.wikipedia.org/wiki/Oz_(Programmiersprache) "Oz (Programmiersprache)"))
-   mengen-orientierte Abfragesprachen (unter anderem [SQL](https://de.wikipedia.org/wiki/SQL "SQL"))

**Beispiel [Quicksort](https://de.wikipedia.org/wiki/Quicksort "Quicksort")**: [Haskell](https://de.wikipedia.org/wiki/Haskell_(Programmiersprache) "Haskell (Programmiersprache)") ist eine typische deklarative Programmiersprache. Der Programmierer beschreibt, _was_ das Programm mit einer Eingabe macht, also wie mit welcher Eingabe umzugehen ist, wobei der Berechnungsablauf nicht von Interesse ist. Die Berechnungen erfolgen dann durch Wertemanipulation. Hauptkontrollstruktur bildet die [Rekursion](https://de.wikipedia.org/wiki/Rekursion "Rekursion"), insbesondere aus Effizienzgründen die [Endrekursion](https://de.wikipedia.org/wiki/Endrekursion "Endrekursion"):

 quicksort [] = []
 quicksort (x:xs) = quicksort [n | n<-xs, n<x] ++ [x] ++ quicksort [n | n<-xs, n>=x]

# Funktionale Programmierung

Die Aufgabenstellung und die bekannten [Prämissen](https://de.wikipedia.org/wiki/Pr%C3%A4misse "Prämisse") werden hier als funktionaler Ausdruck formuliert. Das selbstständige Anwenden von Funktionsersetzung und Auswertung seitens des [Interpreters](https://de.wikipedia.org/wiki/Interpreter "Interpreter") oder [Compilers](https://de.wikipedia.org/wiki/Compiler "Compiler") lösen dann die Aufgabenstellung. Das Programm kann als Abbildung der Eingabe auf die Ausgabe aufgefasst werden.

# Logische Programmierung

Die Aufgabenstellung und ihre [Prämissen](https://de.wikipedia.org/wiki/Pr%C3%A4misse "Prämisse") werden als logische Aussagen (Regeln) formuliert (vgl. funktionale Programmierung, s. o.). Der [Interpreter](https://de.wikipedia.org/wiki/Interpreter "Interpreter") versucht dann, die gewünschte Lösungsaussage herzuleiten. Bei anderen regelbasierten Sprachen wie [OPS-5](https://de.wikipedia.org/w/index.php?title=OPS-5&action=edit&redlink=1 "OPS-5 (Seite nicht vorhanden)"), [XSLT](https://de.wikipedia.org/wiki/XSLT "XSLT") oder [Prolog](https://de.wikipedia.org/wiki/Prolog_(Programmiersprache) "Prolog (Programmiersprache)") werden Regeln gegen eine Datenmenge auf ihre Instanziierbarkeit geprüft. Aus allen Regelinstanziierungen wird eine (mehrere, alle) ausgewählt und die zur Regel gehörenden Anweisungen werden ausgeführt.

# Constraintprogrammierung
Bei der Constraintprogrammierung werden [Constraints](https://de.wikipedia.org/wiki/Einschr%C3%A4nkung "Einschränkung") definiert. Sie wird als natürliche Weiterentwicklung der logischen Programmierung verstanden. Logische und Constraintprogrammierung werden typischerweise in Kombination eingesetzt.

# Objektorientierung

[Klassen](https://de.wikipedia.org/wiki/Klasse_(Objektorientierung) "Klasse (Objektorientierung)") sind instanziierbare Module und Grundelemente in der [objektorientierten Programmierung](https://de.wikipedia.org/wiki/Objektorientierte_Programmierung). Nach dem objektorientierten Programmierparadigma werden Objekte mit Daten und den darauf arbeitenden [Routinen](https://de.wikipedia.org/wiki/Routine_(Programmierung) "Routine (Programmierung)") zu Einheiten zusammengefasst. Im Unterschied dazu werden beim prozeduralen Paradigma die Daten von den die Objekte verarbeitenden Routinen getrennt gehalten. Ein [Computerprogramm](https://de.wikipedia.org/wiki/Computerprogramm "Computerprogramm") ist realisiert als eine Menge interagierender [Objekte](https://de.wikipedia.org/wiki/Objekt_(Programmierung) "Objekt (Programmierung)").

Objektorientierte Programmierung lässt sich gut mit der [ereignisorientierten Programmierung](https://de.wikipedia.org/wiki/Ereignisorientierte_Programmierung "Ereignisorientierte Programmierung") kombinieren, z. B. bei der Programmierung interaktiver, [grafischer Benutzeroberflächen](https://de.wikipedia.org/wiki/Grafische_Benutzeroberfl%C3%A4che "Grafische Benutzeroberfläche").


# Komponentenorientierte Programmierung

Mithilfe der [komponentenbasierten Entwicklung](https://de.wikipedia.org/wiki/Komponentenbasierte_Entwicklung "Komponentenbasierte Entwicklung") von Software mit abstrakten und [generischen](https://de.wikipedia.org/wiki/Generische_Programmierung "Generische Programmierung") [Komponentenmodellen](https://de.wikipedia.org/wiki/Komponentenmodell "Komponentenmodell") können [Softwarekomponenten](https://de.wikipedia.org/wiki/Komponente_(Software) "Komponente (Software)") mit streng definierten [Schnittstellen](https://de.wikipedia.org/wiki/Schnittstelle#Softwareschnittstellen "Schnittstelle") erstellt werden.

Durch die [Wiederverwendbarkeit](https://de.wikipedia.org/wiki/Wiederverwendbarkeit "Wiederverwendbarkeit") von Software-Bausteinen kann der [Entwicklungsaufwand](https://de.wikipedia.org/wiki/Softwaretechnik "Softwaretechnik") und die [Fehleranfälligkeit](https://de.wikipedia.org/wiki/Programmfehler "Programmfehler") reduziert sowie die [Informationssicherheit](https://de.wikipedia.org/wiki/Informationssicherheit "Informationssicherheit") erhöht werden. Durch die vollständige und strenge [Datenkapselung](https://de.wikipedia.org/wiki/Datenkapselung_(Programmierung)) wird ferner die [Portabilität](https://de.wikipedia.org/wiki/Plattformunabh%C3%A4ngigkeit "Plattformunabhängigkeit") von Daten und Programmen erleichtert.


# Agentorientierte Programmierung
Bei der _agentenorientierten Programmierung_ steht der Begriff des [autonomen](https://de.wikipedia.org/wiki/Autonomie "Autonomie") und [planenden](https://de.wikipedia.org/wiki/Planung "Planung") [Agenten](https://de.wikipedia.org/wiki/Software-Agent "Software-Agent") im Vordergrund, der selbstständig und in [Kooperation](https://de.wikipedia.org/wiki/Kooperation "Kooperation") mit anderen Agenten Probleme löst.


# Aspektorientierte Programmierung

Bei der _aspektorientierten Programmierung_ wird der objektorientierte Begriff der [Klasse](https://de.wikipedia.org/wiki/Klasse_(Objektorientierung) "Klasse (Objektorientierung)") zum Aspekt erweitert und ermöglicht so [orthogonale](https://de.wikipedia.org/wiki/Orthogonalit%C3%A4t_(Informatik) "Orthogonalität (Informatik)") Programmierung.

# Generative Programmierung

Generative Programmierung ist ein Überbegriff für die programmatische Erzeugung von Sourcecode

# Generische Programmierung

In der _generischen Programmierung_ wird versucht, die [Algorithmen](https://de.wikipedia.org/wiki/Algorithmus "Algorithmus") für mehrere [Datentypen](https://de.wikipedia.org/wiki/Datentyp) verwendbar zu gestalten.

# Datenstromorientierte Programmierung

Es wird von einem kontinuierlichen Datenfluss ausgegangen (meist Audio- oder Videodaten), der (oft in [Echtzeit](https://de.wikipedia.org/wiki/Echtzeit "Echtzeit")) verändert und ausgegeben wird.


