

### Rule
Rules are instructions that you _must_ do, as required by the language. Failure to abide by a rule will generally result in your program not working.

### Best practice
Best practices are things that you _should_ do, because that way of doing things is generally considered a standard or highly recommended. That is, either everybody does it that way (and if you do otherwise, you’ll be doing something people don’t expect), or it is superior to the alternatives.

### Warning
Warnings are things that you _should not_ do, because they will generally lead to unexpected results.

## the twin evils: 

### the _ellipsis_ (also known as _…_) 
where a necessary or non-obvious part of an example is omitted in the interest of space

### the _unexplained new concept_, 
where a new concept that is integral to the example is introduced without any mention of what it is or how it works. 

Both of these tend to lead to getting stuck.

Modern computers are incredibly fast, and getting faster all the time. However, computers also have some significant constraints: they only natively understand a limited set of commands, and must be told exactly what to do.
When a computer program is loaded into memory and the hardware sequentially executes each instruction, this is called running or executing the program.

### Machine Language
A computer’s CPU is incapable of speaking C++. The limited set of instructions that a CPU can understand directly is called machine code (or machine language or an instruction set).

Here is a sample machine language instruction: `10110000 01100001`

Back when computers were first invented, programmers had to write programs directly in machine language, which was a very difficult and time consuming thing to do.

First, each instruction is composed of a sequence of 1s and 0s. Each individual 0 or 1 is called a binary digit, or bit for short. The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86 family, which you are likely using) have instructions that can be a variable length.Second, each set of binary digits is interpreted by the CPU into a command to do a very specific job, such as _compare these two numbers_, or _put this number in that memory location_.This meant programs generally weren’t portable (usable without major rework) to different types of system, and had to be written all over again.

### Assembly Language
Because machine language is so hard for humans to read and understand, assembly language was invented. In an assembly language, each instruction is identified by a short abbreviation (rather than a set of bits), and names and other numbers can be used.

Here is the same instruction as above in assembly language: `mov al, 061h`This makes assembly much easier to read and write than machine languagethe assembly program must be translated into machine language before it can be executed by the computer. This is done by using a program called an assembler. Programs written in assembly languages tend to be very fast, and assembly is still used today when speed is critical.assembly languages still require a lot of instructions to do even simple tasks assembly language still isn’t very pa program written in assembly for one CPU will likely not work on hardware that uses a different instruction set, and would have to be rewritten or extensively modified.  
Step 3: Write the program

### Best practice

Name your code files _something.cpp_, where _something_ is a name of your choosing, and _.cpp_ is the extension that indicates the file is a C++ source file.

  
### Step 4 
Compiling your source code The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important taskFirst, it checks your code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.Second, it translates your C++ source code into a machine language file called an object file. Object files are typically named _name.o_ or _name.obj_, where _name_ is the same name as the .cpp file it was produced from.

### Step 5 
Linking object files and librariesanother program called the linker kicks inFirst, to take all the object files generated by the compiler and combine them into a single executable program.Second, in addition to being able to link object files, the linker also is capable of linking library files. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. C++ Standard Library_iostream library_, which contains functionality for printing text on a monitor and getting keyboard input from a userMost linkers will automatically link in the standard library as soon as you use any part of itYou can also optionally link in other librariesnot want to write your own code to read in the sound files from disk, check to ensure they were valid, or figure out how to route the sound data to the operating system or hardware to play through the speaker -- that would be a lot of work!a library that already knew how to do those things, and use that. Third, the linker makes sure all cross-file dependencies are resolved properly. if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two togetherlinker error, and the linking process will abort

### For advanced readers
For complex projects, some development environments use a **makefile**, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways). Entire books have been written about how to write and maintain makefiles, and they can be an incredibly powerful tool. However, because makefiles are not part of the C++ core language, nor do you need to use them to proceed, we’ll not discuss them as part of this tutorial series.

### Steps 6 & 7

#### Testing and Debugging
Many (but not all) IDEs include a C++ compiler and a linker,IDEs typically bundle a number of other helpful editing features, such as integrated help, name completion, auto-formatting, and sometimes a version control system.

You should not be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).


https://web.stanford.edu/class/cs148/hws/cs148-hw1.pdf
https://web.stanford.edu/class/cs148/hws/cs148-hw1.pdf

https://cs0112.github.io/Pages/setup.html
